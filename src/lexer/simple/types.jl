# === Lexer definition ===

"""
Regex alias definition.

Defines a regex alias with a `name` and a PCRE2-compliant regex `pattern`:
```
name pattern
```

Regex aliases are used to simplify lexer definitions. They are expanded during
lexer generation.
"""
struct RegexAlias
  name::Symbol
  pattern::String
end

"""
Lexer action definition.

Defines a lexer action with a `pattern` and a `body`:
```
pattern :{ body }:
```

Action `body` is a string of Julia code that is executed when a `pattern` is matched.
"""
struct LexerAction
  pattern::String
  body::String
end

"""
Lexer options definition.

Currently only `tag` option is supported. It defines the tag that will be preprended
to all objects generated in the lexer file.
"""
struct LexerOptions <: Comparable
  tag::String # :tag

  function LexerOptions(
    options::Dict = Dict()
  )::LexerOptions
    return new(
      get(options, :tag, "__LEX__")
    )
  end
end

"""
Lexer definition.

Defines a lexer with a set of `actions`, `aliases`, `code_blocks` and `options`.
Created by `read_lexer_definition_file` function.
"""
struct Lexer <: Comparable
  actions::Vector{LexerAction}
  aliases::Vector{RegexAlias}
  code_blocks::Vector{String}
  options::LexerOptions
end

# === Generated lexer tokens ===

"""
Lexer token definition.

Contains a `name` and a set of `arguments` that will be passed to the token constructor
inside of generated lexer file.
"""
struct LexerTokenDefinition <: Comparable
  name::Symbol
  arguments::Vector{NamedTuple}
end

"""
Lexer token type.

By default, all LexerTokens will inherit this type and have some default members
generated by the lexer generator.

# Example of a generated token
```julia
struct Num <: LexerToken
    symbol::Symbol   # This is the name of the token
    values::Dict     # Dict of all values passed during token creation
                     # Those values may be typed, but it is not required
                     # You can access those values by using simple member access notation (token.value)
    file_pos::String # File position of the token
    ???              # Anything else that may be added in the future
end
```
"""
abstract type LexerToken <: Comparable end

"""
    token_symbol(token::LexerToken)::Symbol

Return the symbol associated with the token.
"""
function token_symbol(token::LexerToken)::Symbol
  return getfield(token, :symbol)
end

"""
    Base.getproperty(token::LexerToken, name::Symbol)

Support for member access notation (token.value)
"""
function Base.getproperty(token::LexerToken, name::Symbol)
  return getfield(token, :values)[name]
end

"""
    token_values(token::LexerToken)::Dict

Return all values passed during token creation.
"""
function token_values(token::LexerToken)::Dict
  return getfield(token, :values)
end

"""
    token_file_pos(token::LexerToken)::String

Return the file position of the token.
"""
function token_file_pos(token::LexerToken)::String
  return getfield(token, :file_pos)
end

#=== Mustache helpers ===#
# Generate convert method for each struct that will be used during mustache rendering
# Custom types cannot be printed during mustache rendering, so we need to convert them
# to strings
for _struct in (:LexerAction, :LexerTokenDefinition)
  @eval Base.convert(::Type{String}, _s::$_struct)::String = repr(_s)
end
