%option LALR

%{
abstract type Operand end
add(a::Operand, b::Operand)::Operand = a + b
sub(a::Operand, b::Operand)::Operand = a - b
mul(a::Operand, b::Operand)::Operand = a * b
div(a::Operand, b::Operand)::Operand = a / b

struct GF{P} <: Operand
  value::Int
  GF{P}(value::Int) where {P} = new(mod(value, P))
end
(Base.:+)(a::GF{P}, b::GF{P}) where P = GF{P}(a.value + b.value)
(Base.:-)(a::GF{P}, b::GF{P}) where P = GF{P}(a.value - b.value)
(Base.:*)(a::GF{P}, b::GF{P}) where P = GF{P}(a.value * b.value)
(Base.:/)(a::GF{P}, b::GF{P}) where P = GF{P}(a.value * invmod(b.value, P))
Base.show(io::IO, a::GF{P}) where P = print(io, "GaloisField{order: $P}($(a.value))")

const FIELD_PRIME::Int = 7
%}

#= Lexer token definitions =#
%token MULTIPLY "*"
%token DIVIDE "/"
%token ADD "+"
%token SUBTRACT "-"
%token LPAREN "("
%token RPAREN ")"
%token NUMBER

#= Returned types =#
%type <GF{FIELD_PRIME}> e
%type <GF{FIELD_PRIME}> t
%type <GF{FIELD_PRIME}> f

%%
#= Productions =#
%start s
s -> e         :{ println($1)                    }:
e -> e "+" t   :{ $$ = add($1, $3)               }:
   | e "-" t   :{ $$ = sub($1, $3)               }:
   | t         :{ $$ = $1                        }:
t -> t "*" f   :{ $$ = mul($1, $3)               }:
   | t "/" f   :{ $$ = div($1, $3)               }:
   | f         :{ $$ = $1                        }:
f -> NUMBER    :{ $$ = GF{FIELD_PRIME}($1.value) }:
   | "(" e ")" :{ $$ = $2                        }:

%%
